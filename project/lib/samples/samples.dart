import 'dart:collection';
import 'dart:math';

import '../sim_components/linear_synapse.dart';

import '../sim_components/soma.dart';
import '../sim_components/synapse.dart';
import '../stimulus/ibit_stream.dart';
import 'input_sample.dart';
import 'soma_sample.dart';
import 'synapse_sample.dart';
import 'value_sample.dart';

/// Captures all data generated by the simulation: Soma and Synapses.
class Samples {
  // Synaptic data. There are N synapses and each is tracked
  // with their own collection.
  // Rendering the queue is based on a sub-window of data.

  /// queue depths are controlled by app_properties.queueDepth
  int queueDepth = 1000; // default
  final int synChannelCnt = 20;
  final int noiseChannelCnt = 10;
  final int stimulusChannelCnt = 10;
  List<ListQueue<SynapseSample>> synSamples = []; // Output
  List<ListQueue<InputSample>> noiseSamples = []; // Input noise
  List<ListQueue<InputSample>> stimulusSamples = []; // Input stimulus

  List<SomaSample> somaSamples = [];

  // A queue for each synapse
  List<ListQueue<ValueSample>> surgeSamples = []; // Input stimulus
  double synapseSurgeMin = 0.0;
  double synapseSurgeMax = 0.0;

  // A queue for each synapse
  List<ListQueue<ValueSample>> pspSamples = []; // Input stimulus
  double synapsePspMin = 0.0;
  double synapsePspMax = 0.0;

  List<ListQueue<ValueSample>> valueAtSamples = []; // Input stimulus
  double synapseValueMin = 0.0;
  double synapseValueMax = 0.0;

  List<ListQueue<ValueSample>> preTraceSamples = []; // Input stimulus
  double preTraceValueMin = 0.0;
  double preTraceValueMax = 0.0;

  // Track vertical scaling by capturing the Min and Max range
  double somaPspMin = 0.0;
  double somaPspMax = 0.0;

  double synapseWeightMin = 0.0;
  double synapseWeightMax = 0.0;

  Samples();

  factory Samples.create() {
    Samples sam = Samples();
    return sam;
  }

  void reset() {
    // ----------------------------------------------------------------
    somaSamples.clear();

    // ----------------------------------------------------------------
    synSamples.clear();
    for (var i = 0; i < synChannelCnt; i++) {
      var listQueue = ListQueue<SynapseSample>(queueDepth);
      for (var i = 0; i < queueDepth; i++) {
        listQueue.add(SynapseSample());
      }
      synSamples.add(listQueue);
    }

    // ----------------------------------------------------------------
    noiseSamples.clear();
    for (var i = 0; i < noiseChannelCnt; i++) {
      var listQueue = ListQueue<InputSample>(queueDepth);
      for (var i = 0; i < queueDepth; i++) {
        listQueue.add(InputSample());
      }
      noiseSamples.add(listQueue);
    }

    // ----------------------------------------------------------------
    stimulusSamples.clear();
    for (var i = 0; i < stimulusChannelCnt; i++) {
      var listQueue = ListQueue<InputSample>(queueDepth);
      for (var i = 0; i < queueDepth; i++) {
        listQueue.add(InputSample());
      }
      stimulusSamples.add(listQueue);
    }

    somaPspMin = 1000000000000.0;
    somaPspMax = -1000000000000.0;

    // ----------------------------------------------------------------
    synapseSurgeMin = 1000000000000.0;
    synapseSurgeMax = -1000000000000.0;

    surgeSamples.clear();

    for (var i = 0; i < synChannelCnt; i++) {
      var listQueue = ListQueue<ValueSample>(queueDepth);

      for (var i = 0; i < queueDepth; i++) {
        ValueSample vs = ValueSample();
        listQueue.add(vs);
      }

      surgeSamples.add(listQueue);
    }

    // ----------------------------------------------------------------
    synapsePspMin = 1000000000000.0;
    synapsePspMax = -1000000000000.0;

    pspSamples.clear();

    for (var i = 0; i < synChannelCnt; i++) {
      var listQueue = ListQueue<ValueSample>(queueDepth);

      for (var i = 0; i < queueDepth; i++) {
        ValueSample vs = ValueSample();
        listQueue.add(vs);
      }

      pspSamples.add(listQueue);
    }

    // ----------------------------------------------------------------
    synapseValueMin = 1000000000000.0;
    synapseValueMax = -1000000000000.0;

    valueAtSamples.clear();

    for (var i = 0; i < synChannelCnt; i++) {
      var listQueue = ListQueue<ValueSample>(queueDepth);

      for (var i = 0; i < queueDepth; i++) {
        ValueSample vs = ValueSample();
        listQueue.add(vs);
      }

      valueAtSamples.add(listQueue);
    }
  }

  void collectSoma(Soma soma, double t) {
    somaPspMin = min(somaPspMin, soma.psp);
    somaPspMax = max(somaPspMax, soma.psp);

    somaSamples.add(SomaSample()
      ..t = t
      ..psp = soma.psp
      ..output = soma.output);
  }

  // Collects a sample from the running synapse not
  // the persistance model
  void collectSynapse(LinearSynapse synapse, double t) {
    // Check if a channel is already in play. Create a new channel if not.
    // if (synSamples.isEmpty || synSamples[id] == null) {
    //   synSamples[id] = ListQueue(queueDepth);
    // }

    synapseWeightMin = min(synapseWeightMin, synapse.w);
    synapseWeightMax = max(synapseWeightMax, synapse.w);

    SynapseSample ss = SynapseSample()
      ..t = t
      ..id = synapse.id
      ..weight = synapse.w
      // ..psp = synapse.psp
      // Input is either Noise or Stimulus
      ..input = synapse.stream.output();

    // The queue is of fixed size. Remove 'first' then add to 'last'.
    synSamples[synapse.id]
      ..removeFirst()
      ..addLast(ss);
  }

  void collectInput(LinearSynapse synapse, double t) {
    IBitStream stream = synapse.stream;
    InputSample ss = InputSample()
      ..t = t
      ..input = stream.output();
    ListQueue<InputSample> sample;
    int id = synapse.id;

    if (stream.btype == BitStreamType.stimulus) {
      id -= synapse.soma.dendrite.minStimulusId;
      sample = stimulusSamples[id];
    } else {
      id -= synapse.soma.dendrite.minNoiseId;
      sample = noiseSamples[id];
    }

    // The queue is of fixed size. Remove 'first' then add to 'last'.
    sample
      ..removeFirst()
      ..addLast(ss);
  }

  void collectSurge(LinearSynapse synapse, double t) {
    int id = synapse.id;

    if (synapse.excititory) {
      synapseSurgeMin = min(synapseSurgeMin, synapse.surgePot);
      synapseSurgeMax = max(synapseSurgeMax, synapse.surgePot);
    } else {
      synapseSurgeMin = min(synapseSurgeMin, synapse.surgeDep);
      synapseSurgeMax = max(synapseSurgeMax, synapse.surgeDep);
    }
    ListQueue<ValueSample> sample = surgeSamples[id];

    ValueSample ss = ValueSample()
      ..t = t
      ..v = synapse.excititory ? synapse.surgePot : synapse.surgeDep;

    sample
      ..removeFirst()
      ..addLast(ss);
  }

  void collectPsp(LinearSynapse synapse, double t) {
    int id = synapse.id;

    synapsePspMin = min(synapsePspMin, synapse.psp);
    synapsePspMax = max(synapsePspMax, synapse.psp);

    ListQueue<ValueSample> sample = pspSamples[id];

    ValueSample ss = ValueSample()
      ..t = t
      ..v = synapse.psp;

    sample
      ..removeFirst()
      ..addLast(ss);
  }

  void collectValue(LinearSynapse synapse, double t) {
    int id = synapse.id;

    synapseValueMin = min(synapseValueMin, synapse.valueAtT);
    synapseValueMax = max(synapseValueMax, synapse.valueAtT);

    ListQueue<ValueSample> sample = valueAtSamples[id];

    ValueSample ss = ValueSample()
      ..t = t
      ..v = synapse.valueAtT;

    sample
      ..removeFirst()
      ..addLast(ss);
  }

  void collect(
    Synapse synapse,
    List<ListQueue<ValueSample>> samples,
    double value,
    double t,
  ) {
    int id = synapse.id;

    synapseValueMin = min(synapseValueMin, value);
    synapseValueMax = max(synapseValueMax, value);

    ListQueue<ValueSample> sample = samples[id];

    ValueSample ss = ValueSample()
      ..t = t
      ..v = value;

    sample
      ..removeFirst()
      ..addLast(ss);
  }
}
