import 'dart:collection';
import 'dart:math';

import 'samples_data.dart';
import '../sim_components/linear_synapse.dart';
import '../sim_components/soma.dart';
import '../sim_components/synapse.dart';
import '../stimulus/ibit_stream.dart';
import 'input_sample.dart';
import 'soma_sample.dart';
import 'synapse_sample.dart';
import 'value_sample.dart';

/// Captures all data generated by the simulation: Soma and Synapses.
class Samples {
  // Synaptic data. There are N synapses and each is tracked
  // with their own collection.
  // Rendering the queue is based on a sub-window of data.

  /// queue depths are controlled by app_properties.queueDepth
  int queueDepth = 1000; // default
  final int synChannelCnt = 20;
  final int noiseChannelCnt = 10;
  final int stimulusChannelCnt = 10;

  SamplesData samplesData = SamplesData()..init();

  // Track vertical scaling by capturing the Min and Max range
  // double somaPspMin = 0.0;
  // double somaPspMax = 0.0;

  double synapseWeightMin = 0.0;
  double synapseWeightMax = 0.0;

  Samples();

  factory Samples.create() {
    Samples sam = Samples();
    return sam;
  }

  void reset() {
    // ----------------------------------------------------------------
    // samplesData.somaSamples.clear();
    samplesData.somaAxon.clear();
    samplesData.somaAxon.init(1, queueDepth);

    // ----------------------------------------------------------------
    samplesData.synSamples.clear();
    for (var i = 0; i < synChannelCnt; i++) {
      var listQueue = ListQueue<SynapseSample>(queueDepth);
      for (var i = 0; i < queueDepth; i++) {
        listQueue.add(SynapseSample());
      }
      samplesData.synSamples.add(listQueue);
    }

    // ----------------------------------------------------------------
    samplesData.noiseSamples.clear();
    for (var i = 0; i < noiseChannelCnt; i++) {
      var listQueue = ListQueue<InputSample>(queueDepth);
      for (var i = 0; i < queueDepth; i++) {
        listQueue.add(InputSample());
      }
      samplesData.noiseSamples.add(listQueue);
    }

    // ----------------------------------------------------------------
    samplesData.stimulusSamples.clear();
    for (var i = 0; i < stimulusChannelCnt; i++) {
      var listQueue = ListQueue<InputSample>(queueDepth);
      for (var i = 0; i < queueDepth; i++) {
        listQueue.add(InputSample());
      }
      samplesData.stimulusSamples.add(listQueue);
    }

    // somaPspMin = double.infinity;
    // somaPspMax = double.negativeInfinity;

    // ----------------------------------------------------------------
    samplesData.surge.reset();
    samplesData.surge.init(synChannelCnt, queueDepth);

    // ----------------------------------------------------------------
    samplesData.psp.reset();
    samplesData.psp.init(synChannelCnt, queueDepth);

    // ----------------------------------------------------------------
    samplesData.valueAt.reset();
    samplesData.valueAt.init(synChannelCnt, queueDepth);

    samplesData.init();
  }

  void collectSoma(Soma soma, double t) {
    samplesData.somaAxon.addSample(
      t,
      0,
      soma.output.toDouble(),
    );
  }

  // Collects a sample from the running synapse not
  // the persistance model
  // TODO convert to samples_data
  void collectSynapse(Synapse synapse, double t) {
    // Check if a channel is already in play. Create a new channel if not.
    // if (synSamples.isEmpty || synSamples[id] == null) {
    //   synSamples[id] = ListQueue(queueDepth);
    // }

    synapseWeightMin = min(synapseWeightMin, synapse.w);
    synapseWeightMax = max(synapseWeightMax, synapse.w);

    SynapseSample ss = SynapseSample()
      ..t = t
      ..id = synapse.id
      ..weight = synapse.w
      // ..psp = synapse.psp
      // Input is either Noise or Stimulus
      ..input = synapse.stream.output();

    // The queue is of fixed size. Remove 'first' then add to 'last'.
    samplesData.synSamples[synapse.id]
      ..removeFirst()
      ..addLast(ss);
  }

  void collectInput(Synapse synapse, double t) {
    IBitStream stream = synapse.stream;
    InputSample ss = InputSample()
      ..t = t
      ..input = stream.output();
    ListQueue<InputSample> sample;
    int id = synapse.id;

    if (stream.btype == BitStreamType.stimulus) {
      id -= synapse.soma.dendrite.minStimulusId;
      sample = samplesData.stimulusSamples[id];
    } else {
      id -= synapse.soma.dendrite.minNoiseId;
      sample = samplesData.noiseSamples[id];
    }

    // The queue is of fixed size. Remove 'first' then add to 'last'.
    sample
      ..removeFirst()
      ..addLast(ss);
  }

  void collectSurge(LinearSynapse synapse, double t) {
    samplesData.surge.addSample(
      t,
      synapse.id,
      synapse.excititory ? synapse.surgePot : synapse.surgeDep,
    );
  }

  void collectPsp(Synapse synapse, double t) {
    samplesData.psp.addSample(
      t,
      synapse.id,
      synapse.psp,
    );
  }

  void collectPreTrace(Synapse synapse, double t, double value) {
    samplesData.preTraceSamples.addSample(
      t,
      synapse.id,
      value,
    );
  }

  void collectValue(Synapse synapse, double t) {
    samplesData.valueAt.addSample(
      t,
      synapse.id,
      synapse.valueAtT,
    );
  }

  void collect(
    Synapse synapse,
    List<ListQueue<ValueSample>> samples,
    double value,
    double t,
  ) {
    samplesData.valueAt.addSample(
      t,
      synapse.id,
      synapse.valueAtT,
    );
  }
}
